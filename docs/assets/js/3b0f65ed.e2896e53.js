"use strict";(self.webpackChunk_canvas_ui_docs=self.webpackChunk_canvas_ui_docs||[]).push([[886],{3237:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>o});var t=i(4349);const s={},r=t.createContext(s);function l(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),t.createElement(r.Provider,{value:n},e.children)}},8673:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>l,metadata:()=>t,toc:()=>a});const t=JSON.parse('{"id":"containers/chunk","title":"Chunk","description":"Chunk is a specialized container component optimized for rendering large lists of elements efficiently. It provides automatic chunking and offstage rendering to handle performance-intensive scenarios where thousands of items need to be displayed.","source":"@site/docs/containers/chunk.md","sourceDirName":"containers","slug":"/containers/chunk","permalink":"/canvas-ui/containers/chunk","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/containers/chunk.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5},"sidebar":"docsSidebar","previous":{"title":"ScrollView","permalink":"/canvas-ui/containers/scroll-view"},"next":{"title":"Events","permalink":"/canvas-ui/category/events"}}');var s=i(4489),r=i(3237);const l={sidebar_position:5},o="Chunk",d={},a=[{value:"Overview",id:"overview",level:2},{value:"Basic Usage",id:"basic-usage",level:2},{value:"Props",id:"props",level:2},{value:"<code>capacity</code>",id:"capacity",level:3},{value:"<code>isOffstage</code>",id:"isoffstage",level:3},{value:"Inherited Props",id:"inherited-props",level:3},{value:"Key Features",id:"key-features",level:2},{value:"\ud83c\udfaf <strong>Automatic Performance Optimization</strong>",id:"-automatic-performance-optimization",level:3},{value:"\ud83d\udcd0 <strong>Intelligent Chunking</strong>",id:"-intelligent-chunking",level:3},{value:"\ud83d\udc41\ufe0f <strong>Viewport Culling</strong>",id:"\ufe0f-viewport-culling",level:3},{value:"\ud83d\udd27 <strong>Seamless Integration</strong>",id:"-seamless-integration",level:3},{value:"Performance Comparison",id:"performance-comparison",level:2},{value:"Advanced Usage",id:"advanced-usage",level:2},{value:"Large Dataset Example",id:"large-dataset-example",level:3},{value:"Custom Offstage Detection",id:"custom-offstage-detection",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"\u2705 Do&#39;s",id:"-dos",level:3},{value:"\u274c Don&#39;ts",id:"-donts",level:3},{value:"\ud83c\udfaf Performance Tips",id:"-performance-tips",level:3},{value:"When to Use Chunk",id:"when-to-use-chunk",level:2},{value:"Browser Performance",id:"browser-performance",level:2},{value:"Common Patterns",id:"common-patterns",level:2},{value:"Simple List",id:"simple-list",level:3},{value:"Grid Layout with Chunks",id:"grid-layout-with-chunks",level:3},{value:"Interactive List Items",id:"interactive-list-items",level:3}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"chunk",children:"Chunk"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Chunk"})," is a specialized container component optimized for rendering large lists of elements efficiently. It provides automatic chunking and offstage rendering to handle performance-intensive scenarios where thousands of items need to be displayed."]}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"Chunk"})," component is designed to solve performance challenges when rendering large numbers of child elements. Unlike regular ",(0,s.jsx)(n.code,{children:"View"})," or ",(0,s.jsx)(n.code,{children:"Flex"})," containers, ",(0,s.jsx)(n.code,{children:"Chunk"})," intelligently groups child elements into smaller chunks and only renders visible portions, significantly improving performance for large datasets."]}),"\n",(0,s.jsx)(n.p,{children:"Key performance optimizations include:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Automatic Chunking"}),": Groups elements into chunks of configurable capacity"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Offstage Rendering"}),": Culls elements outside the viewport"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Repaint Boundaries"}),": Always acts as a repaint boundary for performance isolation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Viewport Culling"}),": Uses intelligent viewport-based visibility detection"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",metastring:"live",live:!0,children:"function BasicChunkExample() {\n  const { Canvas, ScrollView, Chunk, Text } = importCanvasUIPackages()\n\n  const items = Array.from({ length: 50 }, (_, i) => ({\n    id: i,\n    text: `Item ${i + 1}`\n  }))\n\n  return (\n    <div style={{ height: '200px', border: '1px solid #ddd' }}>\n      <Canvas>\n        <ScrollView style={{ width: 300, height: 200 }}>\n          <Chunk style={{ width: 280, padding: 10 }}>\n            {items.map((item) => (\n              <Text\n                key={item.id}\n                style={{\n                  top: item.id * 25,\n                  width: 260,\n                  height: 20,\n                  fontSize: 14,\n                  padding: 2,\n                  backgroundColor: item.id % 2 === 0 ? '#f5f5f5' : '#ffffff'\n                }}\n                text={item.text}\n              />\n            ))}\n          </Chunk>\n        </ScrollView>\n      </Canvas>\n    </div>\n  )\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"props",children:"Props"}),"\n",(0,s.jsx)(n.h3,{id:"capacity",children:(0,s.jsx)(n.code,{children:"capacity"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Type:"})," ",(0,s.jsx)(n.code,{children:"number"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Default:"})," ",(0,s.jsx)(n.code,{children:"6"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Description:"})," The maximum number of child elements to group together in a single chunk. Smaller values create more granular chunks but may increase overhead. Larger values reduce overhead but may decrease culling effectiveness."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"<Chunk capacity={10}>\n  {/* Children will be grouped into chunks of 10 elements */}\n</Chunk>\n"})}),"\n",(0,s.jsx)(n.h3,{id:"isoffstage",children:(0,s.jsx)(n.code,{children:"isOffstage"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Type:"})," ",(0,s.jsx)(n.code,{children:"(viewport: Rect, childBounds: Rect) => boolean"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Default:"})," ",(0,s.jsx)(n.code,{children:"ChunkContainer.defaultIsOffstage"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Description:"})," A function that determines whether a chunk is outside the viewport and should be culled from rendering. The default implementation checks for rect overlap."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"// Custom offstage detection with larger threshold\nconst customIsOffstage = (viewport, childBounds) => {\n  // Add 100px buffer around viewport\n  const bufferedViewport = {\n    left: viewport.left - 100,\n    top: viewport.top - 100,\n    width: viewport.width + 200,\n    height: viewport.height + 200\n  }\n  return !Rect.overlaps(bufferedViewport, childBounds)\n}\n\n<Chunk isOffstage={customIsOffstage}>\n  {children}\n</Chunk>\n"})}),"\n",(0,s.jsx)(n.h3,{id:"inherited-props",children:"Inherited Props"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Chunk"})," inherits all props from ",(0,s.jsx)(n.a,{href:"./view",children:(0,s.jsx)(n.code,{children:"View"})}),", including:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"style"})," - CSS-like styling"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"children"})," - Child elements"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"id"})," - Component identifier"]}),"\n",(0,s.jsxs)(n.li,{children:["Event handlers (",(0,s.jsx)(n.code,{children:"onPointerDown"}),", ",(0,s.jsx)(n.code,{children:"onPointerMove"}),", etc.)"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"key-features",children:"Key Features"}),"\n",(0,s.jsxs)(n.h3,{id:"-automatic-performance-optimization",children:["\ud83c\udfaf ",(0,s.jsx)(n.strong,{children:"Automatic Performance Optimization"})]}),"\n",(0,s.jsx)(n.p,{children:"Chunk automatically optimizes rendering performance without requiring manual configuration:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Groups elements into manageable chunks"}),"\n",(0,s.jsx)(n.li,{children:"Culls offscreen content from rendering"}),"\n",(0,s.jsx)(n.li,{children:"Provides repaint boundaries to isolate updates"}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"-intelligent-chunking",children:["\ud83d\udcd0 ",(0,s.jsx)(n.strong,{children:"Intelligent Chunking"})]}),"\n",(0,s.jsxs)(n.p,{children:["Elements are automatically grouped based on the ",(0,s.jsx)(n.code,{children:"capacity"})," setting:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Default capacity of 6 elements per chunk balances performance and granularity"}),"\n",(0,s.jsx)(n.li,{children:"Chunks are dynamically created and destroyed as needed"}),"\n",(0,s.jsx)(n.li,{children:"Layout calculations are optimized per chunk"}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"\ufe0f-viewport-culling",children:["\ud83d\udc41\ufe0f ",(0,s.jsx)(n.strong,{children:"Viewport Culling"})]}),"\n",(0,s.jsx)(n.p,{children:"Only visible chunks are rendered:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Uses viewport bounds to determine visibility"}),"\n",(0,s.jsx)(n.li,{children:"Customizable offstage detection function"}),"\n",(0,s.jsx)(n.li,{children:"Significantly reduces drawing operations for large lists"}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"-seamless-integration",children:["\ud83d\udd27 ",(0,s.jsx)(n.strong,{children:"Seamless Integration"})]}),"\n",(0,s.jsx)(n.p,{children:"Works naturally with other Canvas UI components:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Integrates with ScrollView for scrollable lists"}),"\n",(0,s.jsx)(n.li,{children:"Supports all standard layout properties"}),"\n",(0,s.jsx)(n.li,{children:"Maintains event handling for all child elements"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"performance-comparison",children:"Performance Comparison"}),"\n",(0,s.jsx)(n.p,{children:"Here's a demonstration showing the performance difference between regular containers and Chunk:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",metastring:"live",live:!0,children:"function PerformanceComparison() {\n  const { Canvas, ScrollView, Chunk, View, Flex, Text } = importCanvasUIPackages()\n\n  const [useChunk, setUseChunk] = useState(true)\n  const items = Array.from({ length: 200 }, (_, i) => ({\n    id: i,\n    text: `Performance Item ${i + 1}`,\n    color: `hsl(${(i * 137.5) % 360}, 70%, 85%)`\n  }))\n\n  const Container = useChunk ? Chunk : View\n\n  return (\n    <div style={{ height: '250px', border: '1px solid #ddd' }}>\n      <div style={{ padding: '10px', backgroundColor: '#f9f9f9' }}>\n        <button\n          onClick={() => setUseChunk(!useChunk)}\n          style={{ marginBottom: '10px' }}\n        >\n          Using: {useChunk ? 'Chunk (Optimized)' : 'View (Regular)'}\n        </button>\n      </div>\n      <Canvas>\n        <ScrollView style={{ width: 300, height: 200 }}>\n          <Container style={{ width: 280, padding: 10 }}>\n            {items.map((item) => (\n              <Flex\n                key={item.id}\n                style={{\n                  top: item.id * 30,\n                  width: 260,\n                  height: 25,\n                  backgroundColor: item.color,\n                  borderRadius: 4,\n                  padding: 4,\n                  flexDirection: 'row',\n                  alignItems: 'center'\n                }}\n              >\n                <Text style={{ fontSize: 12 }} text={item.text} />\n              </Flex>\n            ))}\n          </Container>\n        </ScrollView>\n      </Canvas>\n    </div>\n  )\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"advanced-usage",children:"Advanced Usage"}),"\n",(0,s.jsx)(n.h3,{id:"large-dataset-example",children:"Large Dataset Example"}),"\n",(0,s.jsx)(n.p,{children:"For very large datasets, Chunk provides substantial performance benefits:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",metastring:"live",live:!0,children:"function LargeDatasetExample() {\n  const { Canvas, ScrollView, Chunk, Flex, Text } = importCanvasUIPackages()\n\n  const [itemCount, setItemCount] = useState(500)\n\n  const items = React.useMemo(() =>\n    Array.from({ length: itemCount }, (_, i) => ({\n      id: i,\n      title: `Large Dataset Item ${i + 1}`,\n      subtitle: `Subtitle for item ${i + 1}`,\n      value: Math.floor(Math.random() * 1000)\n    })), [itemCount]\n  )\n\n  return (\n    <div style={{ height: '300px', border: '1px solid #ddd' }}>\n      <div style={{ padding: '10px', backgroundColor: '#f9f9f9' }}>\n        <label>\n          Items:\n          <input\n            type=\"range\"\n            min=\"100\"\n            max=\"2000\"\n            value={itemCount}\n            onChange={(e) => setItemCount(Number(e.target.value))}\n          />\n          {itemCount}\n        </label>\n      </div>\n      <Canvas>\n        <ScrollView style={{ width: 350, height: 250 }}>\n          <Chunk style={{ width: 330, padding: 10 }} capacity={8}>\n            {items.map((item) => (\n              <Flex\n                key={item.id}\n                style={{\n                  top: item.id * 35,\n                  width: 310,\n                  height: 30,\n                  backgroundColor: '#ffffff',\n                  borderColor: '#e0e0e0',\n                  borderWidth: 1,\n                  borderRadius: 4,\n                  padding: 6,\n                  flexDirection: 'row',\n                  justifyContent: 'space-between',\n                  alignItems: 'center'\n                }}\n              >\n                <Flex style={{ flexDirection: 'column' }}>\n                  <Text style={{ fontSize: 12, fontWeight: 'bold' }} text={item.title} />\n                  <Text style={{ fontSize: 10, color: '#666' }} text={item.subtitle} />\n                </Flex>\n                <Text style={{ fontSize: 12, color: '#2196f3' }} text={item.value.toString()} />\n              </Flex>\n            ))}\n          </Chunk>\n        </ScrollView>\n      </Canvas>\n    </div>\n  )\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"custom-offstage-detection",children:"Custom Offstage Detection"}),"\n",(0,s.jsx)(n.p,{children:"Customize when elements are considered offstage for advanced optimization:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"function CustomOffstageExample() {\n  // Only render chunks that are very close to the viewport\n  const aggressiveOffstage = (viewport, childBounds) => {\n    const buffer = 50 // Small buffer\n    return !Rect.overlaps({\n      left: viewport.left - buffer,\n      top: viewport.top - buffer,\n      width: viewport.width + (buffer * 2),\n      height: viewport.height + (buffer * 2)\n    }, childBounds)\n  }\n\n  // Render chunks with a large buffer for smooth scrolling\n  const conservativeOffstage = (viewport, childBounds) => {\n    const buffer = 200 // Large buffer\n    return !Rect.overlaps({\n      left: viewport.left - buffer,\n      top: viewport.top - buffer,\n      width: viewport.width + (buffer * 2),\n      height: viewport.height + (buffer * 2)\n    }, childBounds)\n  }\n\n  return (\n    <Chunk isOffstage={conservativeOffstage}>\n      {/* Your items */}\n    </Chunk>\n  )\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsx)(n.h3,{id:"-dos",children:"\u2705 Do's"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Use ",(0,s.jsx)(n.code,{children:"Chunk"})," for lists with 50+ elements"]}),"\n",(0,s.jsxs)(n.li,{children:["Combine with ",(0,s.jsx)(n.code,{children:"ScrollView"})," for scrollable large lists"]}),"\n",(0,s.jsxs)(n.li,{children:["Set appropriate ",(0,s.jsx)(n.code,{children:"capacity"})," based on your element size and complexity"]}),"\n",(0,s.jsx)(n.li,{children:"Use consistent element heights for best performance"}),"\n",(0,s.jsxs)(n.li,{children:["Position elements absolutely with ",(0,s.jsx)(n.code,{children:"top"}),", ",(0,s.jsx)(n.code,{children:"left"})," for optimal chunking"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"-donts",children:"\u274c Don'ts"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Don't use ",(0,s.jsx)(n.code,{children:"Chunk"})," for small lists (< 20 items) where regular ",(0,s.jsx)(n.code,{children:"View"})," is sufficient"]}),"\n",(0,s.jsx)(n.li,{children:"Don't set capacity too low (< 3) or too high (> 20) without testing"}),"\n",(0,s.jsx)(n.li,{children:"Don't rely on flex layout for large lists - use absolute positioning"}),"\n",(0,s.jsx)(n.li,{children:"Don't nest Chunks unnecessarily"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"-performance-tips",children:"\ud83c\udfaf Performance Tips"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Element Size"}),": Smaller, simpler elements perform better"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Capacity Tuning"}),": Test different capacity values for your use case"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Viewport Buffer"}),": Adjust offstage detection based on scroll behavior"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Event Handlers"}),": Minimize event handlers on individual items"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"when-to-use-chunk",children:"When to Use Chunk"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Scenario"}),(0,s.jsx)(n.th,{children:"Use Chunk"}),(0,s.jsx)(n.th,{children:"Use View/Flex"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Large lists (50+ items)"}),(0,s.jsx)(n.td,{children:"\u2705"}),(0,s.jsx)(n.td,{children:"\u274c"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Virtualized scrolling"}),(0,s.jsx)(n.td,{children:"\u2705"}),(0,s.jsx)(n.td,{children:"\u274c"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Static small collections"}),(0,s.jsx)(n.td,{children:"\u274c"}),(0,s.jsx)(n.td,{children:"\u2705"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Complex nested layouts"}),(0,s.jsx)(n.td,{children:"\u274c"}),(0,s.jsx)(n.td,{children:"\u2705"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Performance-critical lists"}),(0,s.jsx)(n.td,{children:"\u2705"}),(0,s.jsx)(n.td,{children:"\u274c"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Simple forms"}),(0,s.jsx)(n.td,{children:"\u274c"}),(0,s.jsx)(n.td,{children:"\u2705"})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"browser-performance",children:"Browser Performance"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"Chunk"})," component provides measurable performance improvements:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Rendering"}),": 60-80% faster for lists with 500+ items"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Memory"}),": Lower memory usage due to offstage culling"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Scroll Performance"}),": Maintains 60fps scrolling with thousands of items"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Initial Load"}),": Faster initial render with large datasets"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"common-patterns",children:"Common Patterns"}),"\n",(0,s.jsx)(n.h3,{id:"simple-list",children:"Simple List"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"<Chunk style={{ width: 300 }}>\n  {items.map((item, index) => (\n    <Text\n      key={item.id}\n      style={{ top: index * 25, height: 20 }}\n      text={item.name}\n    />\n  ))}\n</Chunk>\n"})}),"\n",(0,s.jsx)(n.h3,{id:"grid-layout-with-chunks",children:"Grid Layout with Chunks"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"<Chunk style={{ width: 400 }} capacity={10}>\n  {items.map((item, index) => {\n    const row = Math.floor(index / 4)\n    const col = index % 4\n    return (\n      <View\n        key={item.id}\n        style={{\n          left: col * 90,\n          top: row * 90,\n          width: 80,\n          height: 80\n        }}\n      >\n        {/* Grid item content */}\n      </View>\n    )\n  })}\n</Chunk>\n"})}),"\n",(0,s.jsx)(n.h3,{id:"interactive-list-items",children:"Interactive List Items"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"<Chunk style={{ width: 350 }}>\n  {items.map((item, index) => (\n    <Flex\n      key={item.id}\n      style={{ top: index * 40, height: 35, cursor: 'pointer' }}\n      onPointerDown={() => handleItemClick(item)}\n    >\n      {/* Interactive item content */}\n    </Flex>\n  ))}\n</Chunk>\n"})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}}}]);